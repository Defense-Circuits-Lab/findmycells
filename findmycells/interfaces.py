# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_interfaces.ipynb.

# %% auto 0
__all__ = ['API', 'PageButtonBundle', 'OverviewPage', 'ProcessingStepPage', 'GUI']

# %% ../nbs/03_interfaces.ipynb 2
from abc import ABC, abstractmethod
from pathlib import Path, PosixPath
from typing import List, Dict, Tuple, Optional, Union
from traitlets.traitlets import MetaHasTraits as WidgetType

import os
import pickle
import random
import pandas as pd
from datetime import datetime
import ipywidgets as w
from IPython.display import display
from ipyfilechooser import FileChooser
from tqdm.notebook import tqdm

from .configs import ProjectConfigs
from .database import Database
from .core import ProcessingStrategy, ProcessingObject
from .preprocessing.specs import PreprocessingStrategy, PreprocessingObject
from .segmentation.specs import SegmentationStrategy, SegmentationObject
from .postprocessing.specs import PostprocessingStrategy, PostprocessingObject
from .quantification.specs import QuantificationStrategy, QuantificationObject

# %% ../nbs/03_interfaces.ipynb 6
class API:
    
    
    def __init__(self, project_root_dir: PosixPath) -> None:
        assert type(project_root_dir) == PosixPath, '"project_root_dir" must be pathlib.Path object referring to an existing directory.'
        assert project_root_dir.is_dir(), '"project_root_dir" must be pathlib.Path object referring to an existing directory.'
        self.project_configs = ProjectConfigs(root_dir = project_root_dir)
        self.database = Database(project_configs = self.project_configs)
        
    
    def update_database_with_current_source_files(self) -> None:
        self.database.compute_file_infos()
        
        
    def set_microscopy_reader_configs(self,
                                      microscopy_reader_configs: Optional[Dict]=None
                                     ) -> None:
        microscopy_reader_configs = self._assert_and_update_reader_configs_input(reader_type = 'microscopy_images',
                                                                                 reader_configs = microscopy_reader_configs)
        self.project_configs.add_reader_configs(reader_type = 'microscopy_images', reader_configs = microscopy_reader_configs)
        
        
    def set_roi_reader_configs(self,
                               roi_reader_configs: Optional[Dict]=None
                              ) -> None:
        roi_reader_configs = self._assert_and_update_reader_configs_input(reader_type = 'rois', reader_configs = roi_reader_configs)
        self.project_configs.add_reader_configs(reader_type = 'rois', reader_configs = roi_reader_configs)
    
    
    
    def save_status(self) -> None:
        date = f'{datetime.now():%Y_%m_%d}'
        dbase_filename = f'{date}_findmycells_database.dbase'
        self._save_attr_to_disk(attr_id = 'database', filename = dbase_filename, child_attr_ids_to_del = ['project_configs'])
        configs_filename = f'{date}_findmycells_project.configs'
        self._save_attr_to_disk(attr_id = 'project_configs', filename = configs_filename, child_attr_ids_to_del = ['available_processing_modules'])
        
        
    def load_status(self,
                    project_configs_filepath: Optional[PosixPath]=None,
                    database_filepath: Optional[PosixPath]=None
                   ) -> None:
        if project_configs_filepath != None:
            assert type(project_configs_filepath) == PosixPath, '"project_configs_filepath" must be pathlib.Path object referring to a .configs file.'
            assert project_configs_filepath.suffix == '.configs', '"project_configs_filepath" must be pathlib.Path object referring to a .configs file.'
        else:
            project_configs_filepath = self._look_for_latest_status_file_in_dir(suffix = '.configs', dir_path = self.project_configs.root_dir)
        if database_filepath != None:
            assert type(database_filepath) == PosixPath, '"database_filepath" must be pathlib.Path object referring to a .dbase file'
            assert database_filepath.suffix == '.dbase', '"database_filepath" must be pathlib.Path object referring to a .dbase file'
        else:
            database_filepath = self._look_for_latest_status_file_in_dir(suffix = '.dbase', dir_path = self.project_configs.root_dir)
        if hasattr(self, 'project_configs'):
            delattr(self, 'project_configs')
        if hasattr(self, 'database'):
            delattr(self, 'database')
        self.project_configs = self._load_object_from_filepath(filepath = project_configs_filepath)
        self.project_configs.load_available_processing_modules()
        self.database = self._load_object_from_filepath(filepath = database_filepath)
        setattr(self.database, 'project_configs', self.project_configs)
        
        
    def preprocess(self,
                   strategies: List[PreprocessingStrategy],
                   strategy_configs: Optional[List[Dict]]=None,
                   processing_configs: Optional[Dict]=None,
                   file_ids: Optional[List[str]]=None
                  ) -> None:
        processing_step_id = 'preprocessing'
        strategy_configs, processing_configs, file_ids = self._assert_and_update_input(processing_step_id = processing_step_id,
                                                                                       strategies = strategies,
                                                                                       strategy_configs = strategy_configs,
                                                                                       processing_configs = processing_configs,
                                                                                       file_ids = file_ids)
        self._assert_reader_configs_are_present()
        microscopy_reader_configs = getattr(self.project_configs, 'microscopy_images')
        roi_reader_configs = getattr(self.project_configs, 'rois')
        for file_id in tqdm(file_ids, display = processing_configs['show_progress']):
            preprocessing_object = PreprocessingObject()
            preprocessing_object.prepare_for_processing(file_ids = [file_id], database = self.database)
            preprocessing_object.load_image_and_rois(microscopy_reader_configs = microscopy_reader_configs, roi_reader_configs = roi_reader_configs)
            preprocessing_object.run_all_strategies(strategies = strategies, strategy_configs = strategy_configs)
            preprocessing_object.save_preprocessed_images_on_disk()
            preprocessing_object.save_preprocessed_rois_in_database()
            preprocessing_object.update_database(mark_as_completed = True)
            del preprocessing_object
            if processing_configs['autosave'] == True:
                self.save_status()
                self.load_status()    
    
    
    def segment(self,
                   strategies: List[SegmentationStrategy],
                   strategy_configs: Optional[List[Dict]]=None,
                   processing_configs: Optional[Dict]=None,
                   file_ids: Optional[List[str]]=None
                  ) -> None:
        processing_step_id = 'segmentation'
        strategy_configs, processing_configs, file_ids = self._assert_and_update_input(processing_step_id = processing_step_id,
                                                                                       strategies = strategies,
                                                                                       strategy_configs = strategy_configs,
                                                                                       processing_configs = processing_configs,
                                                                                       file_ids = file_ids)
        file_ids_per_batch = self._split_file_ids_into_batches(file_ids = file_ids, batch_size = processing_configs['batch_size'])
        if processing_configs['run_strategies_individually'] == True:
            self._segment_running_strategies_individually(strategies = strategies,
                                                          strategy_configs = strategy_configs,
                                                          processing_configs = processing_configs,
                                                          file_ids_per_batch = file_ids_per_batch)
        else:
            self._segment_running_strategies_consecutively(strategies = strategies,
                                                           strategy_configs = strategy_configs,
                                                           processing_configs = processing_configs,
                                                           file_ids_per_batch = file_ids_per_batch)
        if processing_configs['clear_tmp_data'] == True:
            all_files_done = self._check_if_all_files_have_finished_current_processing_step(processing_step_id = processing_step_id)
            if all_files_done == True:
                segmentation_object = SegmentationObject()
                dummy_file_id = file_ids_per_batch[0][0]
                segmentation_object.prepare_for_processing(file_ids = [dummy_file_id], database = self.database)
                segmentation_object.clear_all_tmp_data_in_seg_tool_dir()
                del segmentation_object    
    
    
    def postprocess(self,
                    strategies: List[PostprocessingStrategy],
                    strategy_configs: Optional[List[Dict]]=None,
                    processing_configs: Optional[Dict]=None,
                    file_ids: Optional[List[str]]=None
                   ) -> None:
        processing_step_id = 'postprocessing'
        strategy_configs, processing_configs, file_ids = self._assert_and_update_input(processing_step_id = processing_step_id,
                                                                                       strategies = strategies,
                                                                                       strategy_configs = strategy_configs,
                                                                                       processing_configs = processing_configs,
                                                                                       file_ids = file_ids)
        for file_id in tqdm(file_ids, display = processing_configs['show_progress']):
            postprocessing_object = PostprocessingObject()
            postprocessing_object.prepare_for_processing(file_ids = [file_id], database = self.database)
            postprocessing_object.load_segmentations_masks_for_postprocessing(segmentations_to_use = processing_configs['segmentations_to_use'])
            postprocessing_object.run_all_strategies(strategies = strategies, strategy_configs = strategy_configs)
            postprocessing_object.save_postprocessed_segmentations()
            postprocessing_object.update_database(mark_as_completed = True)
            del postprocessing_object
            if processing_configs['autosave'] == True:
                self.save_status()
                self.load_status()    
    
    
    def quantify(self,
                 strategies: List[QuantificationStrategy],
                 strategy_configs: Optional[List[Dict]]=None,
                 processing_configs: Optional[Dict]=None,#
                 file_ids: Optional[List[str]]=None
                ) -> None:
        processing_step_id = 'quantification'
        strategy_configs, processing_configs, file_ids = self._assert_and_update_input(processing_step_id = processing_step_id,
                                                                                       strategies = strategies,
                                                                                       strategy_configs = strategy_configs,
                                                                                       processing_configs = processing_configs,
                                                                                       file_ids = file_ids)
        for file_id in tqdm(file_ids, display = processing_configs['show_progress']):
            quantification_object = QuantificationObject()
            quantification_object.prepare_for_processing(file_ids = [file_id], database = self.database)
            quantification_object.run_all_strategies(strategies = strategies, strategy_configs = strategy_configs)
            quantification_object.update_database(mark_as_completed = True)
            del quantification_object
            if processing_configs['autosave'] == True:
                self.save_status()
                self.load_status()    
    

    def _assert_reader_configs_are_present(self) -> None:
        assert_message = ('You have to specify your {} reader configs first before running ".preprocess()".'
                          'You can do this by running the ".set_{}_reader_configs()" method first!')
        assert hasattr(self.project_configs, 'microscopy_images'), assert_message.format('microscopy image', 'microscopy')
        assert hasattr(self.project_configs, 'rois'), assert_message.format('ROI', 'roi')
                
                
    def _assert_and_update_reader_configs_input(self, reader_type: str, reader_configs: Optional[Dict]) -> Dict:            
        if reader_configs == None:
            if hasattr(self.project_configs, reader_type) == False:
                self.project_configs.add_reader_configs(reader_type = reader_type)
            reader_configs = getattr(self.project_configs, reader_type)
        else:
            assert type(reader_configs) == dict, f'"reader_configs" (data type: {reader_type}) has to be a dictionary!'
            default_configs = self.project_configs.data_reader_default_configs[reader_type]
            default_configs.assert_user_input(user_input = reader_configs)
            reader_configs = default_configs.fill_user_input_with_defaults_where_needed(user_input = reader_configs)
        return reader_configs
    
   
    def _segment_running_strategies_individually(self,
                                                 strategies: List[SegmentationStrategy],
                                                 strategy_configs: List[Dict],
                                                 processing_configs: Dict,
                                                 file_ids_per_batch: List[List[str]]
                                                ) -> None:
        total_strategy_count = len(strategies)
        for i in tqdm(range(total_strategy_count), display = processing_configs['show_progress']):
            if processing_configs['show_progress'] == True:
                print(f'Starting with segmentation strategy #{i+1}')
            strategy, config = strategies[i], strategy_configs[i]
            for batch_file_ids in tqdm(file_ids_per_batch, display = processing_configs['show_progress']):
                if processing_configs['show_progress'] == True:
                    print(f'Starting with batch #{file_ids_per_batch.index(batch_file_ids) + 1}')
                segmentation_object = SegmentationObject()
                segmentation_object.prepare_for_processing(file_ids = batch_file_ids, database = self.database)
                segmentation_object.run_all_strategies(strategies = [strategy], strategy_configs = [config])
                if i == total_strategy_count - 1: # if this is the last strategy that needs to be run
                    segmentation_object.update_database(mark_as_completed = True)
                else:
                    segmentation_object.update_database(mark_as_completed = False)
                del segmentation_object
                if processing_configs['autosave'] == True:
                    self.save_status()
                    self.load_status()


    def _segment_running_strategies_consecutively(self,
                                                  strategies: List[SegmentationStrategy],
                                                  strategy_configs: List[Dict],
                                                  processing_configs: Dict,
                                                  file_ids_per_batch: List[List[str]]
                                                 ) -> None:
        for batch_file_ids in tqdm(file_ids_per_batch, display = processing_configs['show_progress']):
            segmentation_object = SegmentationObject()
            segmentation_object.prepare_for_processing(file_ids = batch_file_ids, database = self.database)
            segmentation_object.run_all_strategies(strategies = strategies, strategy_configs = strategy_configs)
            segmentation_object.update_database(mark_as_completed = True)
            del segmentation_object
            if processing_configs['autosave'] == True:
                self.save_status()
                self.load_status()
                

    def _check_if_all_files_have_finished_current_processing_step(self, processing_step_id: str) -> bool:
        all_file_ids = self.database.file_infos['file_id']
        file_ids_not_processed_yet = []
        for file_id in all_file_ids:
            if processing_step_id not in self.database.file_histories[file_id].completed_processing_steps.keys():
                file_ids_not_processed_yet.append(file_id)
            else:
                if self.database.file_histories[file_id].completed_processing_steps[processing_step_id] == False:
                    file_ids_not_processed_yet.append(file_id)
        return len(file_ids_not_processed_yet) == 0

        
    
    def _save_attr_to_disk(self, attr_id: str, filename: str, child_attr_ids_to_del: List[str]) -> None:
        filepath = self.project_configs.root_dir.joinpath(filename)
        attribute_to_save = getattr(self, attr_id)
        for attr_id_to_del in child_attr_ids_to_del:
            delattr(attribute_to_save, attr_id_to_del)
        filehandler = open(filepath, 'wb')
        pickle.dump(attribute_to_save, filehandler)

        
    def _load_object_from_filepath(self, filepath: PosixPath) -> Union[Database, ProjectConfigs]:
        filehandler = open(filepath, 'rb')
        loaded_object = pickle.load(filehandler)
        return loaded_object
        

    def _split_file_ids_into_batches(self, file_ids: List[str], batch_size: int) -> List[List[str]]:
        """
        Splits a list ("file_ids") of file_id strings into nested lists of file_id strings,
        where the maximum length of each nested list equals the integer passed as "batch_size".
        If "batch_size" matches or exceeds the number of file_id strings passed in the original
        list (i.e. length of "file_ids"), or if "batch_size" is 0, it will return a list with 
        only a single nested list that again contains all file_id strings.
        """
        if batch_size == 0:
            file_ids_per_batch = [file_ids]
        else:
            if len(file_ids) % batch_size == 0:
                total_batches = int(len(file_ids) / batch_size)
            else:
                total_batches = int(len(file_ids) / batch_size) + 1
            file_ids_per_batch = []
            for batch in range(total_batches):
                if len(file_ids) >= batch_size:
                    sampled_file_ids = random.sample(file_ids, batch_size)
                else:
                    sampled_file_ids = file_ids.copy()
                file_ids_per_batch.append(sampled_file_ids)
                for elem in sampled_file_ids:
                    file_ids.remove(elem)    
        return file_ids_per_batch


    def _look_for_latest_status_file_in_dir(self, suffix: str, dir_path: PosixPath) -> PosixPath:
        matching_filepaths = [filepath for filepath in dir_path.iterdir() if filepath.suffix == suffix]
        if len(matching_filepaths) == 0:
            raise FileNotFoundError(f'Could not find a "{suffix}" file in {dir_path}. Consider specifying the exact filepath!')
        else:
            date_strings = [filepath.name[:10] for filepath in matching_filepaths]
            dates = [datetime.strptime(date_str, '%Y_%m_%d') for date_str in date_strings]
            latest_date = max(dates)
            filepath_idx = dates.index(latest_date)
            latest_status_filepath = matching_filepaths[filepath_idx]
        return latest_status_filepath        
        
        
    def _assert_and_update_input(self, 
                                 processing_step_id: str,
                                 strategies: List[PreprocessingStrategy],
                                 strategy_configs: Optional[List[Dict]],
                                 processing_configs: Optional[Dict],
                                 file_ids: Optional[List[str]]
                                ) -> Tuple[List[Dict], Dict, List[str]]:
        self._assert_processing_step_input(processing_step_id = processing_step_id,
                                           strategies = strategies,
                                           strategy_configs = strategy_configs,
                                           processing_configs = processing_configs,
                                           file_ids = file_ids)
        strategy_configs = self._fill_strategy_configs_with_defaults_where_needed(strategies, strategy_configs)
        if processing_configs == None:
            if hasattr(self.project_configs, processing_step_id) == False:
                self.project_configs.add_processing_step_configs(processing_step_id = processing_step_id)
            processing_configs = getattr(self.project_configs, processing_step_id)
        processing_configs = self._fill_processing_configs_with_defaults_where_needed(processing_step_id, processing_configs)
        self.project_configs.add_processing_step_configs(processing_step_id, configs = processing_configs)
        file_ids = self.database.get_file_ids_to_process(input_file_ids = file_ids,
                                                         processing_step_id = processing_step_id,
                                                         overwrite = processing_configs['overwrite'])
        return strategy_configs, processing_configs, file_ids
            
        
    def _assert_processing_step_input(self, 
                                      processing_step_id: str,
                                      strategies: List[PreprocessingStrategy],
                                      strategy_configs: Optional[List[Dict]],
                                      processing_configs: Optional[Dict],
                                      file_ids: Optional[List[str]]
                                     ) -> None:
        assert type(strategies) == list, '"strategies" has to be a list of ProcessingStrategy classes of the respective processing step!'
        if strategy_configs != None:
            assert type(strategy_configs) == list, '"strategy_configs" has to be None or a list of the same length as "strategies"!'
            assert len(strategy_configs) == len(strategies), '"strategy_configs" has to be None or a list of the same length as "strategies"!'
        else:
            strategy_configs = [None] * len(strategies)
        available_strategies = self.project_configs.available_processing_strategies[processing_step_id]
        for strat, config in zip(strategies, strategy_configs):
            assert strat in available_strategies, f'{strat} is not an available strategy for {processing_step_id}!'
            if config != None:
                strat().default_configs.assert_user_input(user_input = config)
        if processing_configs != None:
            processing_obj = self.project_configs.available_processing_objects[processing_step_id]()
            processing_obj.default_configs.assert_user_input(user_input = processing_configs)
        if file_ids != None:
            assert type(file_ids) == list, '"file_ids" has to be a list of strings referring to file_ids in the database!'
            for elem in file_ids:
                assert elem in self.database.file_infos['file_id'], f'{elem} is not a valid file_id!'
        
        
    def _fill_processing_configs_with_defaults_where_needed(self,
                                                            processing_step_id: str,
                                                            processing_configs: Dict
                                                           ) -> Dict:
        processing_obj = self.project_configs.available_processing_objects[processing_step_id]()
        return processing_obj.default_configs.fill_user_input_with_defaults_where_needed(user_input = processing_configs)                                              
             
        
    def _fill_strategy_configs_with_defaults_where_needed(self,
                                                          strategies: List[ProcessingStrategy],
                                                          strategy_configs: Optional[List[Dict]]
                                                         ) -> List[Dict]:
        all_final_configs = []
        if strategy_configs == None:
            for strat in strategies:
                default_configs = strat().default_configs.fill_user_input_with_defaults_where_needed(user_input = {})
                all_final_configs.append(default_configs)
        else:
            for strat, configs in zip(strategies, strategy_configs):
                full_configs = strat().default_configs.fill_user_input_with_defaults_where_needed(user_input = configs)
                all_final_configs.append(full_configs)
        return all_final_configs

# %% ../nbs/03_interfaces.ipynb 10
class PageButtonBundle(ABC):
    
    
    @abstractmethod
    def _initialize_page_content(self) -> WidgetType:
        pass
    
    
    def __init__(self, bundle_id: str, page_screen: WidgetType, all_navigator_buttons: List, api: API) -> None:
        self.bundle_id = bundle_id
        self.gui_page_screen = page_screen
        self.all_navigator_buttons = all_navigator_buttons
        self.api = api
        self.navigator_button = self._initialize_navigator_button()
        self.displayed_output = w.Output()
        self.page_content = self._initialize_page_content()
        
        
    def _initialize_navigator_button(self) -> WidgetType:
        navigator_button = w.Button(description = self.bundle_id, style = {'button_color': 'gray'})
        navigator_button.on_click(self._navigator_button_clicked)
        return navigator_button
    
    
    def _navigator_button_clicked(self, b) -> None:
        for button in self.all_navigator_buttons:
            button.style.button_color = 'gray'
        self.navigator_button.style.button_color = 'skyblue'
        self.gui_page_screen.children = (self.page_content, self.displayed_output)

# %% ../nbs/03_interfaces.ipynb 11
class OverviewPage(PageButtonBundle):
        
    def _initialize_page_content(self) -> WidgetType:
        overview_intro_text = w.HTML(value = ('This is the overview page for your findmycells '
                                              'project. You will find everything relevant regarding '
                                              'the organization of your project in the tabs below. '
                                              'If you have just started your findmycells project, '
                                              'please make sure to follow the instructions in the '
                                              '"project files" tab before you can get started.'))
        project_files_tab_widget = self._initialize_project_files_tab_widget()
        save_load_project_tab_widget = self._initialize_save_load_project_tab_widget()
        data_reader_tab_widget = self._initialize_data_reader_tab_widget()
        browse_file_histories_tab_widget = self._initialize_browse_file_histories_tab_widget()
        self._bind_buttons_to_functions()
        tabs = w.Tab([project_files_tab_widget, 
                      data_reader_tab_widget,
                      browse_file_histories_tab_widget,
                      save_load_project_tab_widget], selected_index = 0)
        tabs.set_title(0, 'project files')
        tabs.set_title(1, 'data import settings')
        tabs.set_title(2, 'browser file histories')
        tabs.set_title(3, 'save & load project')
        page_content_widget = w.VBox([overview_intro_text, tabs])
        return page_content_widget
        
        
    def _initialize_data_reader_tab_widget(self) -> WidgetType:
        intro_text = w.HTML(value = ('Please use the following widgets to specify the settigns of how '
                                     'data (i.e. microscopy images and, if available, ROI-files) shall '
                                     'be imported into your findmycells project:'))
        microscopy_images_reader_settings_widget = self._initialize_data_reader_settings_widget(reader_type = 'microscopy_images')
        rois_reader_settings_widget = self._initialize_data_reader_settings_widget(reader_type = 'rois')
        data_reader_accordion = w.Accordion([microscopy_images_reader_settings_widget, rois_reader_settings_widget])
        data_reader_accordion.set_title(0, 'Microscopy images import settings')
        data_reader_accordion.set_title(1, 'ROI-files import settings')
        return w.VBox([intro_text, data_reader_accordion])
        
        
    def _initialize_data_reader_settings_widget(self, reader_type: str) -> WidgetType:
        reader_specs = self.api.project_configs.available_data_readers[reader_type]()
        reader_specs.initialize_gui_configs_and_widget()
        confirm_reader_settings_button = w.Button(description = 'confirm settings')
        setattr(self, f'{reader_type}_reader_specs', reader_specs)
        setattr(self, f'confirm_{reader_type}_reader_settings_button', confirm_reader_settings_button)
        return w.VBox([reader_specs.widget, confirm_reader_settings_button])       
        
        
        
    def _initialize_project_files_tab_widget(self) -> WidgetType:
        intro_text = w.HTML(value = ('Just started a new project? Great! Before you can get started with '
                                     'the processing of your data, you need to associate the corresponding '
                                     'files with your findmycells project. Unfortunately, this requires you '
                                     'to arrange your files in a very rigid structure of directories (this '
                                     'will be fixed in a later version). But donÂ´t worry, if you click on '
                                     'the "expand me if you need a detailed guide to prepare your data!" '
                                     'widget below you will find a comprehensive overview on how this tree '
                                     'of directories has to look like. Once you have your data arranged '
                                     'accordingly, just click the "update project files" button below. You '
                                     'can also always come back to this page & hit the button again in order '
                                     'to update the files associated with your project. Findmycells will then '
                                     'automatically identify files that have been deleted or added to the '
                                     'directories and remove them from or add them to your current project, '
                                     'respectively. To get an overview of which files are currently associ'
                                     'ated with your project, just click the "display current project files" '
                                     'button right next to the "update project files" button. If you are inter'
                                     'ested in more detailed information about each file, for instance its '
                                     'processing history, please head over to the "file histories" tab.'))
        guide_accordion = self._initialize_guide_accordion_widget()
        self.update_project_files_button = w.Button(description = 'update project files', icon = 'refresh')
        self.display_current_project_files_button = w.Button(description = 'display current project files')
        buttons = w.HBox([self.update_project_files_button, self.display_current_project_files_button])
        self.current_project_files_output = w.Output()
        project_files_tab_widget = w.VBox([intro_text,
                                           guide_accordion,
                                           buttons,
                                           self.current_project_files_output])
        return project_files_tab_widget
    
    
    def _initialize_guide_accordion_widget(self) -> WidgetType:
        # ToDo: write detailed description of directory tree
        # ToDo: add sample image of how this could look like
        # ToDo: what to do for walkthrough through data
        # ToDo: hint that just clicking the button with an empty microscopy dir launches sample tree
        general_info = w.HTML(value = 'space for some general infos')
        detailed_infos = w.HTML(value = 'all details come here')
        sample_image = w.HTML(value = 'this shall be replaced by the sample image')
        whole_guide = w.VBox([general_info, 
                              detailed_infos,
                              sample_image])
        guide_accordion = w.Accordion([whole_guide], selected_index = None)
        guide_accordion.set_title(0, 'expand me if you need a detailed guide to prepare your data!')
        return guide_accordion
        
        
    def _initialize_save_load_project_tab_widget(self) -> WidgetType:
        intro_text = w.HTML(value = ('Here you can either save the progress of your currently '
                                     'running project or load a previously saved project.'))
        save_project_widget = self._initialize_save_project_widget()
        load_project_widget = self._initialize_load_project_widget()
        accordion = w.Accordion([save_project_widget, load_project_widget], selected_index = 0)
        accordion.set_title(0, 'save')
        accordion.set_title(1, 'load')
        save_load_project_tab_widget = w.VBox([intro_text, accordion])
        return save_load_project_tab_widget
    
    
    def _initialize_save_project_widget(self) -> WidgetType:
        save_description = w.HTML(value = ('Clicking the following "save" button will save '
                                           'your current project, including all configurations '
                                           'and processing progress. The file will automatically '
                                           'be written as a ".configs" file to the root directory '
                                           'you specified, with the current date as prefix.'))
        self.save_project_button = w.Button(description = 'save project', icon = 'save')
        save_project_widget = w.VBox([save_description, self.save_project_button])
        return save_project_widget
    
    
    def _initialize_load_project_widget(self) -> WidgetType:
        load_description = w.HTML(value = ('You already have a findmycells project to load? Great! '
                                           'Please make sure to choose the corresponding root dir'
                                           'rectory in which you previously created and run your '
                                           'project upon starting this GUI. If you have specified a '
                                           'different root directory, simply restart the GUI. When '
                                           'you are in the correct root directory, simply click the '
                                           '"load project" button to load your project and the last '
                                           'status you have saved.'))
        self.load_project_button = w.Button(description = 'load project', icon = 'upload')
        # ToDo: 
        #   For the moment you should only load a project from its own root dir.
        #   However, it should be possible in later versions to provide the filepath(s)
        #   to the file(s) that fmc created upon saving the project. This would, consequently,
        #   require the use of filechooser(s). I think it was possible to restrict the selection
        #   to only files with a specific extension (to make sure the user selects the correct
        #   file(s)). In addition, it might be possible to re-configure the default filepath
        #   of the current root dir. 
        load_project_widget = w.VBox([load_description,
                                      self.load_project_button])
        return load_project_widget
    
        
    def _initialize_browse_file_histories_tab_widget(self) -> WidgetType:
        intro_text = w.HTML(value = ('Findmycells keeps a detailed track of how and when your '
                                     'files are processed. Using the widget below, you are '
                                     'able to browser through this history for all files in your '
                                     'project. Note: Unfortunately, this interactive widget is '
                                     'not yet implemented in your current version. Nevertheless, '
                                     'findmycells already tracks the processing history of your '
                                     'files and if you have some experience with python, you can '
                                     'access them at: self.api.database.file_histories, where '
                                     '"self" refers to the GUI object you have instantiated.'))
        self.file_histories_id_dropdown = w.Dropdown(description = 'History of file ID:', 
                                                     style = {'description_width': 'initial'},
                                                     layout = {'width': '66%'})
        self.display_file_history_button = w.Button(description = 'show history', layout = {'width': '33%'})
        dropdown_button_hbox = w.HBox([self.file_histories_id_dropdown, self.display_file_history_button])
        self.file_history_output = w.Output()
        browse_file_hostories_tab_widget = w.VBox([intro_text,
                                                   dropdown_button_hbox,
                                                   self.file_history_output])
        return browse_file_hostories_tab_widget
                                      
        
    def _bind_buttons_to_functions(self) -> None:
        self.update_project_files_button.on_click(self._update_project_files_button_clicked)
        self.display_current_project_files_button.on_click(self._display_current_project_files_button_clicked)
        self.save_project_button.on_click(self._save_project_button_clicked)
        self.load_project_button.on_click(self._load_project_button_clicked)
        self.display_file_history_button.on_click(self._display_file_history_button_clicked)
        self.confirm_microscopy_images_reader_settings_button.on_click(self._confirm_microscopy_images_reader_settings_button_clicked)
        self.confirm_rois_reader_settings_button.on_click(self._confirm_rois_reader_settings_button_clicked)
        
        
    def _confirm_rois_reader_settings_button_clicked(self, b) -> None:
        roi_reader_configs = self.rois_reader_specs.export_current_gui_config_values()
        self.api.set_roi_reader_configs(roi_reader_configs = roi_reader_configs)
        self.confirm_rois_reader_settings_button.description = 'refine settings'
        with self.displayed_output:
            print('ROI-file import settings successfully updated!')
        
    def _confirm_microscopy_images_reader_settings_button_clicked(self, b) -> None:
        microscopy_reader_configs = self.microscopy_images_reader_specs.export_current_gui_config_values()
        self.api.set_microscopy_reader_configs(microscopy_reader_configs = microscopy_reader_configs)
        self.confirm_microscopy_images_reader_settings_button.description = 'refine settings'
        with self.displayed_output:
            print('Microscopy image import settings successfully updated!')
        
        
    def _update_project_files_button_clicked(self, b) -> None:
        self.api.update_database_with_current_source_files()
        self.api.database.compute_file_infos()
        self._update_options_for_file_histories_id_dropdown()
        self._display_current_project_files_button_clicked('simulate a click')
        
    
    def _update_options_for_file_histories_id_dropdown(self) -> None:
        self.file_histories_id_dropdown.options = self.api.database.file_infos['file_id']
        
        
    def _display_current_project_files_button_clicked(self, b) -> None:
        file_infos_df = pd.DataFrame(data = self.api.database.file_infos)
        refreshed_datetime = datetime.now()
        with self.current_project_files_output:
            self.current_project_files_output.clear_output()
            print(f'Data refreshed at {refreshed_datetime:%H:%M:%S} on {refreshed_datetime:%d.%m.%Y}')
            print('\n\n')
            display(file_infos_df)

            
    def _save_project_button_clicked(self, b) -> None:
        self.api.save_status()
    
    
    def _load_project_button_clicked(self, b) -> None:
        self.api.load_status()
        
    
    def _display_file_history_button_clicked(self, b) -> None:
        # ToDo: 
        #   Needs to be implemented. File histories are implemented, yet
        #   it needs to be checked how to best visualize them, as they 
        #   consist of two parts, a pd.DataFrame that tracks the general
        #   processing information (what strategy was run when & was a 
        #   given processing step completed), and a dictionary that lists
        #   the exact parameters (user settings and determined by fmc) 
        #   for each processing step individually
        with self.file_history_output:
            self.file_history_output.clear_output()
            print('Not implemented yet!')

# %% ../nbs/03_interfaces.ipynb 12
class ProcessingStepPage(PageButtonBundle):
    
    #ToDo: 
    # For preprocessing, widgets to configure the DataReaders (microscopy_configs & roi_configs) need to be added!
        
    def _initialize_page_content(self) -> WidgetType:
        self.exported_strategies_with_configs = []
        self._initialize_strategy_selection_accordion()
        self._initialize_processing_configs_widget()
        self._initialize_trigger_widget_elements()
        self._bind_buttons_to_functions()
        widget = w.VBox([self.strat_selection_accordion,
                         self.processing_configs_widget,
                         w.HBox([self.file_ids_range, self.run])])
        return widget
    
    
    def _initialize_processing_configs_widget(self) -> None:
        processing_object_class = self.api.project_configs.available_processing_objects[self.bundle_id] 
        self.processing_obj = processing_object_class()
        self.processing_obj.initialize_gui_configs_and_widget()
        self.confirm_and_processing_configs = w.Button(description = 'confirm & export configurations',
                                                       layout = {'width': '30%'},
                                                       style = {'description_width': 'initial'})
        self.refine_processing_configs = w.Button(description = 'refine configurations',
                                                  disabled = True,
                                                  layout = {'width': '30%'},
                                                  style = {'description_width': 'initial'})
        self.processing_configs_widget = w.VBox([self.processing_obj.widget,
                                                 w.HBox([self.confirm_and_processing_configs, self.refine_processing_configs])])
        
        
    def _initialize_strategy_selection_accordion(self) -> None:
        available_strategy_classes = self.api.project_configs.available_processing_strategies[self.bundle_id]        
        self.strat_selection_accordion = w.Accordion()
        initial_strat_configurator = StrategyConfigurator(available_strategy_classes=available_strategy_classes,
                                                          parent_accordion=self.strat_selection_accordion,
                                                          target_for_configs_export=self.exported_strategies_with_configs)
        self.strat_selection_accordion.children = self.strat_selection_accordion.children + (initial_strat_configurator.widget, )
        self.strat_selection_accordion.set_title(0, 'Expand me to add a processing strategy')
        
        
    def _initialize_trigger_widget_elements(self) -> None:
        all_file_ids = self.api.database.file_infos['file_id']
        self.file_ids_range = w.SelectionRangeSlider(description = 'Select range of file IDs to process: ',
                                                     options = all_file_ids,
                                                     value = (all_file_ids[0], all_file_ids[-1]),
                                                     layout = {'width': '75%'},
                                                     style = {'description_width': 'initial'})
        self.run = w.Button(description = f'Launch {self.bundle_id}',
                            icon = 'rocket',
                            disabled = True,
                            layout = {'width': '25%'},
                            style = {'description_width': 'initial', 'button_color': 'orange'}
                           )

    
    def _bind_buttons_to_functions(self) -> None:
        self.confirm_and_processing_configs.on_click(self._confirm_and_processing_configs_clicked)
        self.refine_processing_configs.on_click(self._refine_processing_configs_clicked)
        self.run.on_click(self._run_clicked)
        
        
    def _confirm_and_processing_configs_clicked(self, b):
        self.processing_configs = self.processing_obj.gui_configs.export_current_config_values()
        self._change_disable_settings_of_customizable_widgets(disable_customizable_widgets = True)
        
    
    def _change_disable_settings_of_customizable_widgets(self, disable_customizable_widgets: bool) -> None:
        self.run.disabled = not disable_customizable_widgets
        self.refine_processing_configs.disabled = not disable_customizable_widgets
        self.confirm_and_processing_configs.disabled = disable_customizable_widgets
        for widget in self.processing_obj.widget.children:
            if hasattr(widget, 'disabled'):
                widget.disabled = disable_customizable_widgets
            elif type(widget) == w.HBox:
                if hasattr(widget.children[0], 'disabled'):
                    widget.children[0].disabled = disable_customizable_widgets
                    
                    
    def _refine_processing_configs_clicked(self, b) -> None:
        self.processing_configs = {}
        self._change_disable_settings_of_customizable_widgets(disable_customizable_widgets = False)
        
        
    def _run_clicked(self, b) -> None:
        self.run.disabled = True
        self.refine_processing_configs.disabled = True
        self._determine_and_call_corresponding_api_function()
        self.run.disabled = False
        self.refine_processing_configs.disabled = False
        
    
    def _determine_and_call_corresponding_api_function(self) -> None:
        file_ids = self._get_file_ids()
        strategies, strategy_configs = self._get_strategies_and_configs()
        if self.bundle_id == 'preprocessing':
            corresponding_api_callable = self.api.preprocess
        elif self.bundle_id == 'segmentation':
            corresponding_api_callable = self.api.segment
        elif self.bundle_id == 'postprocessing':
            corresponding_api_callable = self.api.postprocess
        elif self.bundle_id == 'quantification':
            corresponding_api_callable = self.api.quantify
        else:
            raise NotImplementedError(f'API wrapper for {self.bundle_id} missing!')
        with self.displayed_output:
            self.displayed_output.clear_output()
            corresponding_api_callable(strategies, strategy_configs, self.processing_configs, file_ids)
    
        
    def _get_file_ids(self) -> List[str]:
        all_file_ids = self.api.database.file_infos['file_id']
        start_idx = all_file_ids.index(self.file_ids_range.value[0])
        end_idx = all_file_ids.index(self.file_ids_range.value[1])
        file_ids = all_file_ids[start_idx : end_idx+1]
        return file_ids
    
    
    def _get_strategies_and_configs(self) -> Tuple[List[ProcessingStrategy], List[Dict]]:
        strategies, strategy_configs = zip(*self.exported_strategies_with_configs)
        strategies = list(strategies)
        strategy_configs = list(strategy_configs)
        return strategies, strategy_configs

# %% ../nbs/03_interfaces.ipynb 13
class GUI:
    
    @property
    def _expected_processing_step_modules(self) -> List[str]:
        """
        This list defines the processing steps for which ProcessingStepPages will be created
        in the GUI version of findmycells. It will also be used to compare the elements of this
        list to the list of automatically detected processing modules, which can be found in 
        the "available_processing_modules" attribute of the ProcessingConfigs of the API. In case
        that this list of expected modules is missing an element, it will print a warning to alert
        the user / developer about this. The automatically created list could, unfortunately, not
        be used, as the order of ProcessingStepPages (and the corresponding navigator buttons)
        would not be correct.
        """
        return ['preprocessing', 'segmentation', 'postprocessing', 'quantification']
    
    def __init__(self) -> None:
        self.displayed_widget = self._initialize_start_screen()
        
    
    def _initialize_start_screen(self) -> WidgetType:
        welcome_html = w.HTML(value = ('<br><br>'
                                       '<div style="font-size: 26px" align="center">'
                                       '<b>Welcome to <i>findmycells</i> - glad youÂ´re here! :-)</b>'
                                       '</div><br><br>'
                                       '<div style="font-size: 16px" align="center">'
                                       'Please start by selecting the root directory for your project below. '
                                       'Once you made your selection & are happy with it - click the "launch project" '
                                       'button to launch your project:'))        
        current_working_dir = os.getcwd()
        self.root_dir_chooser = FileChooser(current_working_dir, show_only_dirs = True)
        #self.root_dir_chooser = FileChooser('/mnt/c/Users/dsege/Downloads/fmc_test_project/', show_only_dirs = True)
        self.welcome_page_output = w.Output()
        confirm_root_dir_selection_button = w.Button(description = 'launch project', icon = 'rocket', layout = {'width': '25%'})
        confirm_root_dir_selection_button.on_click(self._confirm_root_dir_selection)
        return w.VBox([welcome_html, self.root_dir_chooser, confirm_root_dir_selection_button, self.welcome_page_output],
                      layout = {'align_items': 'center'})
   
    
    def _confirm_root_dir_selection(self, b) -> None:
        if self.root_dir_chooser.value == None:
            with self.welcome_page_output:
                self.welcome_page_output.clear_output()
                print(('Whoooops - seems like you have not yet made your selection! '
                       'This requires you to click twice on the "select" button. Once '
                       'to open the file explorer widget, and a second time to collapse '
                       'it again. After your second click, you should see the path you '
                       'selected displayed above in green. Once this is the case, please '
                       'click the "launch project" button again.'))
        else:
            selected_root_dir_path = Path(self.root_dir_chooser.value)
            self.api = API(project_root_dir = selected_root_dir_path)
            self._initialize_main_screen()
        
        
    def _initialize_main_screen(self) -> None:
        self.page_screen = w.VBox()
        self.api.update_database_with_current_source_files()
        self._initialize_page_bundles()
        navigator_bar = w.HBox(self.navigator_buttons)
        self.main_screen = w.VBox([navigator_bar, self.page_screen])
        self._refresh_displayed_widget(new_widget = self.main_screen)
        
        
        
    def _initialize_page_bundles(self) -> None:
        self.navigator_buttons = []
        self.overview_page = OverviewPage(bundle_id = 'overview',
                                          page_screen = self.page_screen,
                                          all_navigator_buttons = self.navigator_buttons,
                                          api = self.api)
        self.navigator_buttons.append(self.overview_page.navigator_button)
        # ToDo: add reader configs here?
        self._compare_expected_to_available_processing_modules()
        for processing_step_module in self._expected_processing_step_modules:
            processing_step_page = ProcessingStepPage(bundle_id = processing_step_module,
                                                      page_screen = self.page_screen,
                                                      all_navigator_buttons = self.navigator_buttons,
                                                      api = self.api)
            self.navigator_buttons.append(processing_step_page.navigator_button)
            attr_id = f'{processing_step_module}_page'
            setattr(self, attr_id, processing_step_page)

            
    def _compare_expected_to_available_processing_modules(self) -> None:
        available_processing_modules = list(self.api.project_configs.available_processing_modules.keys())
        for available_module in available_processing_modules:
            if available_module not in self._expected_processing_step_modules:
                print(f'Warning for developers: {available_module} is an available processing module of findmycells,'
                       'which is not yet covered in the GUI! Please also add it to the "_expected_processing_step_modules"'
                       'property of the GUI class in findmycells.interfaces.')
        
    def _refresh_displayed_widget(self, new_widget: WidgetType) -> None:
        self.displayed_widget.children = (new_widget, )
